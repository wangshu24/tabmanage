#!/bin/sh
# pre-push hook
# Blocks console.(log|warn|error) unless guarded by isDev
# Ignores env file where isDevBuild() is defined
# Supports single- and multi-line console calls
# Tracks execution time
# Optimized: only checks staged files being pushed

START_TIME=$(date +%s%N)

IGNORE_FILE="scripts/shared/devTool.js"

# Determine JS files to check:
#  - If run with --all or -a, scan the entire repo (tracked JS files)
#  - Otherwise, read refs from stdin and diff remote_sha..local_sha
MODE_ALL=0
if [ "$1" = "--all" ] || [ "$1" = "-a" ]; then
  MODE_ALL=1
fi

if [ "$MODE_ALL" -eq 1 ]; then
  FILES=$(git ls-files | grep '\.js$' | grep -v "$IGNORE_FILE" | sort -u)
else
  FILES=$(\
    while read -r local_ref local_sha remote_ref remote_sha; do
      # Skip deletes
      if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        continue
      fi
      # If new branch/tag, compare against empty tree; else against remote sha
      if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        range="$local_sha"
      else
        range="$remote_sha..$local_sha"
      fi
      git diff --name-only --diff-filter=ACM $range
    done < /dev/stdin | grep '\.js$' | grep -v "$IGNORE_FILE" | sort -u
  )
fi

# If no JS files to check, skip quickly
if [ -z "$FILES" ]; then
  if [ "$MODE_ALL" -eq 1 ]; then
    echo "✅ No JS files found to check. Done."
  else
    echo "✅ No JS changes to check in this push. Push allowed."
  fi
  exit 0
fi

invalid_logs=""

for file in $FILES; do
    lineno=0
    inside_isDev_block=0
    block_depth=0
    inside_console_log=0
    console_buffer=""
    console_start_line=0
    prev_guard_line=""

    # Read STAGED content (fallback to working tree if not in index)
    tmpfile=$(mktemp)
    if git cat-file -e ":$file" 2>/dev/null; then
        git show ":$file" > "$tmpfile" 2>/dev/null || true
    else
        [ -f "$file" ] && cp "$file" "$tmpfile" 2>/dev/null || true
    fi

    while IFS= read -r line || [ -n "$line" ]; do
        lineno=$((lineno+1))
        trimmed="${line#"${line%%[![:space:]]*}"}"  # trim leading whitespace

        # Track previous non-empty, non-comment line (for chained `isDev &&` then console on next line)
        if [ -n "$(printf "%s" "$trimmed" | tr -d ' ')" ] && ! echo "$trimmed" | grep -qE '^//|^\*'; then
            prev_guard_line="$trimmed"
        fi

        # Update block depth for { } tracking
        opens=$(printf "%s" "$line" | grep -o "{" | wc -l | tr -d ' ')
        closes=$(printf "%s" "$line" | grep -o "}" | wc -l | tr -d ' ')
        block_depth=$((block_depth + opens - closes))
        [ $block_depth -le 0 ] && inside_isDev_block=0

        # Enter isDev block
        case "$trimmed" in
            if\ \(isDev\)*\{*) inside_isDev_block=1 ;;
        esac

        # --- Multi-line console.log handling ---
        if [ $inside_console_log -eq 1 ]; then
            console_buffer="$console_buffer $trimmed"
            # End of multi-line log detected by semicolon
            [[ "$trimmed" == *\; ]] && {
                # Skip if inside isDev block or guarded
                case "$console_buffer" in
                  isDev\ \&\&*) inside_console_log=0; console_buffer=""; continue ;;
                esac
                echo "$console_buffer" | grep -qE '^if\s*\(\s*isDev\s*\)' && { inside_console_log=0; console_buffer=""; continue; }
                [ $inside_isDev_block -eq 1 ] && { inside_console_log=0; console_buffer=""; continue; }

                invalid_logs="$invalid_logs\n$file:$console_start_line: ${console_buffer}"
                inside_console_log=0
                console_buffer=""
            }
            continue
        fi

        # --- Detect console call start ---
        echo "$trimmed" | grep -qE 'console\.[a-zA-Z]+\s*\(' || continue
        # Guard patterns on same line
        echo "$trimmed" | grep -qE '^if\s*\(\s*isDev\s*\).*console\.(log|warn|error)' && continue
        echo "$trimmed" | grep -qE '^isDev\s*&&.*console\.(log|warn|error)' && continue
        # Guard pattern across previous line + current line (e.g., line 33: isDev && \n line 34: console.log(...))
        echo "$prev_guard_line$trimmed" | tr -d '\n' | grep -qE '^isDev\s*&&.*console\.(log|warn|error)' && continue
        [ $inside_isDev_block -eq 1 ] && continue

        # Check if multi-line or single-line
        if [[ "$trimmed" == *\; ]]; then
            invalid_logs="$invalid_logs\n$file:$lineno: $trimmed"
        else
            inside_console_log=1
            console_buffer="$trimmed"
            console_start_line=$lineno
        fi

    done < "$tmpfile"

    rm -f "$tmpfile"
done

END_TIME=$(date +%s%N)
ELAPSED_MS=$(( (END_TIME - START_TIME)/1000000 ))

if [ -n "$invalid_logs" ]; then
    echo "❌ Found unguarded console.log statements in staged files:"
    echo -e "$invalid_logs" | sed 's/^/  • /'
    echo "⏳ Script execution time: ${ELAPSED_MS} ms"
    exit 1
fi

echo "✅ All checks passed. Push allowed."
echo "⏳ Script execution time: ${ELAPSED_MS} ms"
exit 0
